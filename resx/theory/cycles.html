<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Поиск циклов</title>
    <style>
        h1, h2 {
            font-family: Trebuchet MS, sans-serif;
            text-align: justify;
        }
        p {
            font-family: Trebuchet MS, sans-serif;
            text-align: justify;
            font-size: medium;
        }
        code {
            font-family: Consolas,"courier new",serif;
            color: crimson;
            background-color: #f1f1f1;
            padding: 2px;
            font-size: 105%;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>

<h1><a id="заголовок">Проверка включения ребра в цикл<br/></a></h1>
<a href="context.html">К содержанию<br/></a>
<p>
    Проверка включения ребра в <a href="dictionary.html#цикл">цикл</a> на <a href="dictionary.html#граф">графе</a>
    активно используется в алгоритме Краскала при проверке, создаст ли рассматриваемое ребро
    <a href="dictionary.html#цикл">цикл</a> в
    <a href="dictionary.html#минимальное остовное дерево">минимальном остовном дереве</a>.
</p>

<h2><a id="псевдокод">Псевдокод</a></h2>
<p>
    Для проверки включения ребра в цикл используется алгоритм обхода графа в глубину
</p>

<p><b><i>Вход:</i></b> рассматриваемое ребро (u, v)</p>
<p><b><i>Выход:</i></b> содержится ли ребро (u, v) в цикле</p>
<code>
стоп = false
v.состояние = закрыта
положить ребро (u, v) в стек
<b>while</b> !стоп && !стек пустой <b>do</b>
    взять ребро (k, n) с вершины стека
    <b>if</b> n == u <b>then</b>
        стоп = true
    <b>if</b> !стоп && n.состояние == открыта <b>then</b>
        <b>for</b> каждое ребро (n, b) текущей вершины n <b>do</b>
            <b>if</b> b != k <b>then</b>
                положить ребро (n, b) в стек
    <b>else if</b> !стоп && n.состояние == закрыта <b>then</b>
        удалить текущее ребро (k, n) с вершины стека
<b>return</b> стоп
</code>

<p>
    Произведем серию обходов. То есть из каждой вершины, в которую мы ещё ни разу не приходили, запустим поиск в глубину,
    который при входе из текущей вершины в новую вершину будет изменять ее состояние на "закрыта", а текущее ребро
    добавлять в стек. Если алгоритм пытается зайти в закрытую вершину, текущее ребро удаляется из стека. А если алгоритм
    попадает в начальную вершину начального проверяемого ребра, значит, ребро входит в цикл на графе.
</p>
<p>
    В неориентированном графе одно ребро не должно встречаться в цикле дважды по определению. Поэтому необходимо
    проверять, что текущее рассматриваемое из вершины ребро не является тем ребром, по которому мы пришли в эту вершину.
</p>

<h2><a id="пошаговое выполнение">Пошаговое выполнение</a></h2>
<p>Имеем ненаправленный граф с 6 вершинами и 7 ребрами, <b><i>проверяемое ребро - (2, 3)</i></b>. Добавляем его в стек</p>

<p>
    Хоть граф неориентированный, тем не менее, каждое ребро имеет условное начало и условный конец. Пусть в данном
    случае началом ребра будет вершина (2), а концом - (3). Тогда для выполнения условия "ребро входит в цикл"
    необходимо из вершины 3 прийти в вершину 2.
</p>
<p>
    <img src="pics/цикл%20шаги/цикл%20шаг%201.png" width="263" height="245" align="center" vspace="5" hspace="5">
    Стек ребер: 23
</p>

<p>
    Вершины, в которые можно попасть из вершины (3): (4), (6) и (2). По определению
    <a href="dictionary.html#цикл">цикла</a>, мы не можем пройти по одному ребру два раза, значит, в стек добавляем
    только ребра (3, 4) и (3, 6).
</p>
<p>
    <img src="pics/цикл%20шаги/цикл%20шаг%202.png" width="263" height="245" align="center" vspace="5" hspace="5">
    Стек ребер: 23, 34, 36
</p>

<p>
    Аналогично предыдущему шагу, добавляем в стек ребра (6, 1) и (6, 4), на следующем шаге - (4, 5) и (4, 3).
</p>
<p>
    <img src="pics/цикл%20шаги/цикл%20шаг%204.png" width="263" height="245" align="center" vspace="5" hspace="5">
    Стек ребер: 23, 34, 36, 61, 64, 45, 43
</p>

<p>
    Конечная вершина ребра (4, 3) уже была посещена, значит, рассматривать ее больше не нужно. Удаляем ребро (4, 3)
    из стека.
</p>
<p>
    <img src="pics/цикл%20шаги/цикл%20шаг%205.png" width="263" height="245" align="center" vspace="5" hspace="5">
    Стек ребер: 23, 34, 36, 61, 64, 45
</p>

<p>
    Рассматриваем ребро с вершины стека - (4, 5). Вершина 5 висячая, а значит, из нее нельзя никуда прийти, снимаем ее
    со стека.
</p>
<p>
    После удаления ребра (4, 5) из стека нерассмотренных вершин, которые можно было посетить из вершины (4) не осталось -
    рекурсивно удаляем ребра, соединяющие такие вершины.
</p>
<p>
    <img src="pics/цикл%20шаги/цикл%20шаг%206.png" width="263" height="245" align="center" vspace="5" hspace="5">
    Стек ребер: 23, 34, 36, 61
</p>

<p>
    После удаления имеем ребро (3, 6) на вершине стека, рассматриваем его конечную вершину - (1), из нее можно прийти
    в вершину (1), из которой есть путь только в вершину (2), являющуюся импровизированным началом ребра,
    проверяемого на вхождение в цикл - (2, 3), что подтверждает включение ребра (2, 3) в цикл.
</p>
<p>Алгоритм завершен.</p>
<p>
    <img src="pics/цикл%20шаги/цикл%20шаг%207.png" width="263" height="245" align="center" vspace="5" hspace="5">
    Стек ребер: 23, 34, 36, 61, 12
</p>

<h2><a id="оценка">Оценка сложности</a></h2>
<p>
Время работы алгоритма DFS равно <b><i>O(m + n)</i></b>, где:<br/>
    <b>m</b> - количество ребер графа,<br/>
    <b>n</b> - количество вершин графа.<br/>
</p>
<p>
Алгоритм DFS проверяет каждое ребро не более чем два раза (один раз из каждой конечной точки) и, поскольку стек
поддерживает операции вталкивания и выталкивания за время <b>O(1)</b>, он выполняет постоянное число операций в
расчете на реберное разведывание (суммарно за время <b>O(m)</b>). Инициализация требует времени <b>O(n)<sup>2</sup></b>.
</p>

<a href="cycles.html">Вверх</a><br/>
<a href="kruskal.html">К предыдущему разделу</a><br/>
<a href="context.html">К содержанию</a>

</body>

</html>