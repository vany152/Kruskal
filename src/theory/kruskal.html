<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Алгоритм Краскала</title>
    <style>
        h1, h2 {
            font-family: Trebuchet MS, sans-serif;
            text-align: justify;
        }
        p {
            font-family: Trebuchet MS, sans-serif;
            text-align: justify;
            font-size: medium;
        }
        code {
            font-family: Consolas,"courier new",serif;
            color: crimson;
            background-color: #f1f1f1;
            padding: 2px;
            font-size: 105%;
            white-space: pre;
        }
    </style>
</head>

<body style="font-family: Trebuchet MS, sans-serif">

<h1><a id="заголовок">Алгоритм Краскала<br/></a></h1>
<a href="context.html">К содержанию<br/></a>
<p>
    Алгоритм Краскала - один из эффективных алгоритмов поиска <a href="dictionary.html#минимальное остовное дерево">
    минимального остовного дерева</a> <a href="dictionary.html#связный граф">связного</a>
    <a href="dictionary.html#взвешенный граф">взвешенного</a> <a href="dictionary.html#граф">неориентированного графа</a>.
</p>
<p> Алгоритм описан в 1956 году нидерландским ученым Джозефом Краскалом. </p>
<p>
    Минимальные остовные деревья могут применяться в задачах о связывании коммуникациями населенных пунктов, например,
    в задаче о соединении нескольких населенных пунктов телефонной линией.
</p>

<h2><a id="формулировка">Формулировка</a></h2>
<p>
    В начале текущее множество рёбер устанавливается пустым. Затем, пока это возможно, проводится следующая операция:
    из всех рёбер, добавление которых к уже имеющемуся множеству не вызовет появление в нём
    <a href="dictionary.html#цикл">цикла</a>, выбирается ребро минимального веса и добавляется к уже имеющемуся
    множеству. Когда таких рёбер больше нет, алгоритм завершён. Подграф данного графа, содержащий все его вершины и
    найденное множество рёбер, является его <b><i>остовным деревом минимального веса</i></b>.
</p>

<h2><a id="представление графа">Представление графа в виде списка смежности</a></h2>
<p>
    Одни из удобных представлений графа является представление в виде списков смежности.
</p>
<p>
    Список смежности сводится к двум массивам: первый для отслеживания ребер и второй для отслеживания вершин. Оба
    массива ссылаются друг на друга, причем каждое ребро содержит два указателя на вершины, которые оно связывает,
    а каждая вершина ссылается на все ребра, для которых она является конечной точкой.
</p>

<h2><a id="псевдокод">Псевдокод</a></h2>
<p>
    <b><i>Вход:</i></b> связный неориентированный граф <b>G = (V, E)</b>, представленный в виде списков смежности,
    и стоимость <b>c<sub>e</sub></b> для каждого ребра <b>e ∈ E</b>.
</p>
<p> <b><i>Выход:</i></b> ребра минимального остовного дерева графа <b>G</b> - множество <b>T</b>. </p>
<code>
// Предобработка
T = ∅

// Главный цикл
<b>for</b> каждое ребро e ∈ E, в неуменьшающемся порядке стоимости <b>do</b>
    <b>if</b> T ∪ {e} является ациклическим <b>then</b>
         T = T ∪ {e}
return TS
</code>
<p>
    Алгоритм Краскала последовательно рассматривает ребра входного графа (от самого дешевого до самого дорогого),
    поэтому на этапе предобработки имеет смысл отсортировать их в неуменьшающемся порядке стоимости. Связи между
    ребрами можно разрывать произвольно. Основной цикл проходит через ребра, добавляя ребро в текущее решение, если оно
    не создает <a href="dictionary.html#цикл">цикл</a>. В итоге алгоритм Краскала возвращает остовное дерево минимальной
    стоимости.
</p>

<h2><a id="пошаговое выполнение">Пошаговое выполнение</a></h2>
<p>Имеем взвешенный ненаправленный граф с пятью вершинами и 7 ребрами</p>
<img src="pics/мод%20шаги/мод%20шаг%200.png" width="330" height="220" alt="Шаг 1">

<p>
    Алгоритм Краскала строит остовное дерево по одному ребру за раз. Алгоритм может выращивать многочисленные
    деревья параллельно, сливая результаты в единое дерево только в конце алгоритма. Таким образом, алгоритм
    Краскала свободен в выборе самого дешевого оставшегося ребра во всем графе, отдавая предпочтение самому
    дешевому ребру, не создающему цикл.
</p>
<p>
    В примере алгоритм Краскала начинает с пустого множества ребер T и на своей первой итерации рассматривает
    самое дешевое ребро (ребро со стоимостью 1) и добавляет его в T. Вторая итерация следует той же процедуре,
    выбирая следующее самое дешевое ребро (ребро со стоимостью 2). В этом месте множество T текущего решения
    выглядит так:
</p>
<img src="pics/мод%20шаги/мод%20шаг%201.png" width="330" height="220" alt="Шаг 2">

<p>
    Два ребра, выбранные к настоящему моменту, не пересекаются, поэтому алгоритм практически выращивает два
    дерева параллельно. На следующей итерации рассматривается ребро со стоимостью 3. Его включение не создает
    цикла, случайным образом соединяя два текущих дерева:
</p>
<img src="pics/мод%20шаги/мод%20шаг%202.png" width="330" height="220" alt="Шаг 3">

<p>
    Далее алгоритм рассматривает ребро со стоимостью 4. Добавление этого ребра в T создаст цикл (с участием ребер
    со стоимостями 2 и 3), поэтому алгоритм вынужден его пропустить. Следующим оптимальным вариантом является ребро
    со стоимостью 5; его включение не создает цикла и, по сути дела, приводит к остовному дереву:
</p>
<img src="pics/мод%20шаги/мод%20шаг%203.png" width="330" height="220" alt="Шаг 4">

<p>
    Алгоритм пропускает ребро со стоимостью 6 (которое создало бы треугольник с участием ребер со стоимостями 3 и 5),
    а также конечное ребро со стоимостью 7 (которое создало бы треугольник с участием ребер со стоимостями 1 и 5).
    Приведенный выше конечный выход представляет собой минимальное остовное дерево графа.
</p>

<h2><a id="оценка">Оценка сложности</a></h2>
<p>
    Сложность алгоритма: <b><i>O(m*n)</i></b> где:<br/>
    <b>m</b> - количество ребер графа,<br/>
    <b>n</b> - количество вершин графа.
</p>
<p>
    На этапе предобработки алгоритм сортирует массив ребер входного графа, который содержит m элементов. При хорошем
    алгоритме сортировки (например, сортировке слиянием) этот шаг вносит вклад в <b><i>O(m log n)</i></b>-работу в
    совокупное время выполнения. Эта работа всецело зависит от того, что делается главным циклом алгоритма.
</p>
<p>
    Главный цикл имеет <b>m</b> итераций. Каждая итерация отвечает за проверку того, можно или нельзя добавить
    рассматриваемое
    ребро <b>e = (v, w)</b> в текущее решение <b>T</b> без создания цикла. Добавление <b>e</b> в <b>T</b> создает цикл
    тогда и только тогда, когда <b>T</b> уже содержит путь <b>v–w</b>. Последнее условие может быть проверено за
    линейное время с использованием любого разумного алгоритма поиска в графе, такого как поиск в ширину или в глубину,
    начиная с <b>v</b>. Под <i>«линейным временем»</i> подразумевается линейный размер графа <b>(V, T)</b>, который, как
    ациклический граф с <b>n</b> вершинами, имеет не более <b>n − 1</b> ребер. Таким образом, время выполнения за
    итерацию равно <b>O(n)</b>, давая совокупное время выполнения <b><i>O(m*n)</i></b>.
</p>

<a href="kruskal.html">Вверх</a><br/>
<a href="cycles.html">К следующему разделу</a><br/>
<a href="context.html">К содержанию</a>

</body>

</html>